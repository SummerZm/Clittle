关于Unicode，字符集，字符编码
===================================
必要、清晰、且准确的概念，是一切思考的基石。所谓思考，很大程度上，就是在建立那些概念与概念之间的关联。
概念是必要、清晰、且准确的，它们之间的关联也应该是准确的。

A. 基本概念
	1. 字符[character]: 字符代表了字母表中的字符，标点符号和其他的一些符号。在计算机中，文本是由字符组成的。

	2. 字符集合[character set]: 由一套用于特定用途的字符组成，例如支持西欧语言的字符集合，支持中文的字符集合。字符集合只定义了符号和他们的语意。
		a. “字符集合”和“字符编码”一般都是同时制定的。例如: ASCII字符集合。

B. 字符编码[character encoding]
	1. 字符集中的每个字符与计算机内存中字节之间的转换关系
	2. 规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储。
		a. ASCII编码[你没看错，它既是一种字符集合，也是一种字符编码]
		b. Unicode字符集合，有好几种字符编码方式，例如变长度编码的UTF8，UTF16等
	 
C. UCS和ISO 10646标准
	1. Unicode财团和国际化标准组织都已经同意会让Unicode和ISO 10646标准互相兼容并会在未来紧密协作
		a. 1991年左右，两个项目的成员都意识到世界不需要两个统一的字符集。于是他们一起合作制定了一个字符表。

D. UTF8
	1. Unicode/UCS只是字符集合，虽然为每个字符分配了一个唯一的整数值，但具体怎么用字节来表示每个字符，是由字符编码决定的。
	2. Unicode的字符编码方式有UTF-8, UTF-16, UTF-32。
	3. UTF-16和UTF-32编码中包含"\0",或者"/"这样对于文件名和其他C语言库函数来说具有特殊意义的字符，所以不适合在Unix下用来做文件名称，文本和环境变量的Unicode编码。
	4. UTF-8没有这样的问题，它有很多优点：可以向前兼容ASCII码，是变长的编码，由于编码没有状态，所以很容易重新同步，在传输过程中丢失了一些字节后，具有鲁棒性。

E. POSIX语系[locale]机制
	1. 语系[locale]就是软件运行时的语言环境，它是语言和文化规则的一个集合，包含字符编码，日期/时间的表示方式，字符排序的规则等。
	2. 语系的名称通常是由ISO 639-1规定的语言[language]和ISO 3166-1规定的国家代码[country code]以及额外的字符编码名称[character encoding]共同组成。
		例如zh_TW.UTF-8语系
		a. zh代表语言是汉语;
		b. TW是台湾地区;
		c. UTF-8是字符编码。

	3. 语系环境变量
		a. LC_CTYPE决定字符编码方式
		b. LC_COLLATE决定字符排序的规则
		c. LANG环境变量用来设置所有类别的默认语。最低优先级。

F. C语言对Unicode和UTF-8的支持
	1. C语言标准支持两种不同的方式来处理扩展的自然语言编码方式：宽字符[wide characters]和多字节字符[multibyte characters]。

	2. 宽字符[wide characters]
		a. 宽字符是一种内部表示方式，每个字符是用一个单独的wchar_t类型来表示的。
			-- wchar_t这种类型是从GNU glibc 2.2开始引入;
			-- 目的是在运行时用单个的对象来表示字符，跟当前使用的语系无关。
			-- ISO C99标准要求通过宏__STDC_ISO_10646__来告诉程序支持wchar_t类型，并且保证所有的宽字符处理函数都会把宽字符当作Unicode字符。
			-- 宽字符函数: 多数是在处理char类型字符的函数名基础上，添加了"w"或者是把"str"替换成"wcs",例如wprintf(),wscpy()等。
			-- 字符串常量: 添加L前缀就可以告诉让编译器用wchar_t类型来存储字符串常量。-- printf("%ls\n", L"Schöne Grüße")

		c. 2011版的C和C++标准都各自引入了固定大小的字符类型char16_t和char32_t来明确提供16位和32位Unicode编码格式，让wchar_t成为实现相关的类型。
		
		d. ISO 10646:2003 Unicode 4.0标准 
			-- wchar_t类型的宽度是由编译器指定的，可以小到只有8位。因此对于需要在C或C++编译器之间可移植的程序不应该使用wchar_t来存储Unicode文本。
			-- wchar_t类型的目的是存储编译器定义的宽字符，有可能不是用Unicode编码的。
	
	3. 多字节字符[multibyte characters]
		a. 多字节字符是用来做输入和输出的，每个字符用C语言中char类型的序列来表示。所以每个字符会用一个或多个(最多MB_LEN_MAX)字节来表示
		b. 多字节字符的字符编码方式，是由当前系统的语系[locale]来决定的。
			-- 例如当前语系中字符编码是UTF-8，那么多字节字符编码就是UTF-8。因此语系也控制着宽字符和多字节之间的转换。

	4. glibc2.2及更高版本完整地实现ISO 
		a. C语言多字节转换函数（mbsrtowcs(), wcsrtomb()等）。这些函数用来在wchar_t和任何语系相关的多字节编码，包括UTF-8,ISO 8859-1等之间进行转化。
		b. 建议是使用这些函数中可重启动的[restartable,函数名中有字母r],是多线程安全的函数，例如wcsrtombs(), mbsrtowcs()。
			-- 好处：
				是跟厂商无关的标准
				函数会根据用户的语系做正确的事情。程序需要做的是在程序开头调用setlocale(LC_ALL, "")来根据环境变量来设置用户语系

		c. 例如可以写出如下代码：
			#include <stdio.h>
			#include <locale.h>

			int main()
			{
				if (!setlocale(LC_CTYPE, "")) {
					fprintf(stderr, "Can't set the specified locale! "
			          "Check LANG, LC_CTYPE, LC_ALL.\n");
					return 1;
				}
				printf("%ls\n", L"Schöne Grüße");
				return 0;
			} 

			setlocale(LC_CTYPE, "")函数，会依次测试环境变量 LC_ALL, LC_CTYPE和 LANG的值;
			如果有值，就用这个值来决定用哪个语系数据来加载LC_CTYPE这个分类(控制着多字节转换的函数）。

			printf中的%ls格式说明符是用来指定把宽字符形式的字符串参数转化成由语系决定的多字节编码来输出。
			printf函数是不知道输出的字符的编码方式的，它会把传给它的字节原封不动地输出出去。
			在显示的时候，操作系统会根据当前的语系来将这些字节解码到对应的字符，
			所以只有当传给printf的字符编码方式和用户环境变量指定的字符编码方式相同，用printf打印出的字符才不会乱码。

		d. 使用这些函数的坏处：
			 -- 有些函数是非线程安全的，因为两次函数调用之间有隐藏的内部状态, 不能同时支持多种语系或编码方式

		e. 程序如何当前语系是什么?
				-- 在程序开始处调用setlocale(LC_TYPE, ""函数来根据环境变量设置语系。
				-- 之后利用函数nl_langinfo(CODESET)函数来获得当前语系指定的字符编码的名称。

		f. 如果全部都使用C语言库中多字节的函数来进行外部字符编码和程序内部使用的wchar_t类型之间的转换，
			那么C语言库会根据环境变量LC_CTYPE的值来选择正确的字符编码，你的程序甚至不用显示地知道当前多字节编码是什么。

G. C语言如何书写采用了某种字符编码的字符串常量
	1. 转义序列
		a. 转义是以多个字符的有序组合来表示原本很难直接表示出来的字符的技术。转义序列指在转义时使用的有序字符组合。
		b. 了解C语言中如下的几个转义方式：
			-- '\798':值为十进制值798的字符
			-- '\x7D':值为十六进制7D的字符
			-- '\u0041':代表字符名称中名为U+0041的这个Unicode字符，可能最终编译器会用几个字节来存储这个字符。这种方式只有C99以后才支持。
			由编译器来决定具体用什么方式存储。

		c. 写出特定编码的字符串了，例如"我是Jack47"，采用各种编码形式的值如下：
			-- char gbk_name[] = "\xced2\xcac7Jack47";
			-- char unicode_name[] = "\u6211\u662FJack47"
			-- char utf8_name[] = "\xe6\x88\x91\xe6\x98\xafJack47"
			上述的这种方式，是直接把编码后的字节写入到了数组里，是一种"硬编码"[hard code]的方式。
	
	2. 当前软件要支持UTF8，要如何修改？
		a. 硬编码的方法
		b. 把UTF-8相关的信息硬编码到程序中。这样能够在某些场景下显著提高程序执行效率。这或许是那些只需要支持ASCII和UTF-8编码的程序的最好办法。

H. Java与Unicode
	1. Java语言内部使用的就是Unicode编码。char类型表示一个Unicode字符[这是跟C语言不一样的地方]，java.lang.String类表示一个从Unicode字符构建的字符串。
	2. java.io.DataInput和java.io.DataOutput接口分别有叫做readUTF和writeUTF的方法。但记住他们使用的不是UTF-8;
		他们用的是修改后的UTF-8编码：NUL字符不是用一个字节的0x00来表示，而是用两个字节的0xC0 0x80来表示的，在最后添加一个字节的0x00。
		这样编码，字符串包含NUL字符而不需要增加表示字符串长度的前缀字段--这样C语言<string.h>中定义的strlen()和strcpy这些函数就可以用来操作这些数据了。

I. 程序在做内部计算时通常以宽字符编码，如果要存盘或者输出给别的程序，或者通过网络发给别的程序，则采用多字节编码。

J. mysqls输入编码和环境变量的字符编码不一样会有问题吗？

